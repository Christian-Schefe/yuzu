export fn std_test() {
    print("Hello from std.yuzu");
}

export class IndexIterator {
    constructor(array) {
        {array: array, index: 0}
    }
    fn next() {
        if (this.index < this.array.length()) {
            let value = this.array[this.index];
            this.index += 1;
            {value: value}
        }
    }
}

export class Function {
    fn call() this();
    fn partial_apply(...args) {
        fn wrapper(...extra_args) {
            this(...args, ...extra_args);
        }
        wrapper
    }
}
export class Bool {}
export class Null {}

export class ClassInstance {}
export class Class {}
export class Number {
    fn abs() if (this < 0) { -this } else { this }
}
export class Integer {
    fn abs() if (this < 0) { -this } else { this }
}
export class String {}

export class AsyncResource {
    async fn close() {
        await intrinsics::resource_close_async(this);
    }
    async fn read(buffer) {
        await intrinsics::resource_read_async(this, buffer)
    }
    async fn write(buffer) {
        await intrinsics::resource_write_async(this, buffer)
    }
    async fn write_string(string) {
        let buffer = intrinsics::buffer_from_string(string);
        await intrinsics::resource_write_async(this, buffer);
    }
}

export class Resource {
    fn close() {
        intrinsics::resource_close(this);
    }
    fn read(buffer) {
        intrinsics::resource_read(this, buffer)
    }
    fn write(buffer) {
        intrinsics::resource_write(this, buffer)
    }
}

export class Buffer {
    static fn with_size(size) intrinsics::buffer_with_size(size);
    fn length() intrinsics::buffer_length(this);
    fn slice(start, length) intrinsics::buffer_slice(this, start, length);
    fn to_string() intrinsics::buffer_to_string(this);
}

export class ByteArray {
    constructor(capacity) {
        let buffer = Buffer.with_size(capacity);
        let view = intrinsics::uint8_array_of(buffer);
        {buffer: buffer, view: view, length: 0, capacity: capacity}
    }

    fn push(byte) {
        if (this.length >= this.capacity) {
            this.capacity = this.capacity * 2;
            let new_buffer = Buffer.with_size(this.capacity);
            intrinsics::buffer_copy(this.buffer, new_buffer.slice(0, this.length));
            this.buffer = new_buffer;
            this.view = intrinsics::uint8_array_of(this.buffer);
        }
        this.view[this.length] = byte;
        this.length += 1;
    }

    fn clear() {
        this.length = 0;
        this.buffer = Buffer.with_size(this.capacity);
        this.view = intrinsics::uint8_array_of(this.buffer);
    }

    fn as_slice() intrinsics::buffer_slice(this.buffer, 0, this.length);
}

export class BufferedReader {
    constructor(resource) {
        let buffer = new ByteArray(1024);
        {resource: resource, buffer: buffer}
    }
    fn readline() {
        let has_read = false;
        while (true) {
            let buffer = intrinsics::buffer_with_size(1);
            let bytes_read = this.resource.read(buffer);
            if (bytes_read == 0) {
                break;
            }
            has_read = true;
            let uint8_buffer = intrinsics::uint8_array_of(buffer);
            let byte = uint8_buffer[0];
            print("Read byte:", bytes_read, byte);
            //ignore carriage returns
            if (byte == 13) { // carriage return
                continue;
            }
            if (byte == 10) { // newline
                break;
            }
            this.buffer.push(byte);
        }
        if (!has_read) {
            return null;
        }
        let line = intrinsics::buffer_to_string(this.buffer.as_slice());
        this.buffer.clear();
        line
    }
    async fn readline_async() {
        let has_read = false;
        while (true) {
            let buffer = intrinsics::buffer_with_size(1);
            let bytes_read = await this.resource.read(buffer);
            if (bytes_read == 0) {
                break;
            }
            has_read = true;
            let uint8_buffer = intrinsics::uint8_array_of(buffer);
            let byte = uint8_buffer[0];
            print("Read byte:", bytes_read, byte);
            //ignore carriage returns
            if (byte == 13) { // carriage return
                continue;
            }
            if (byte == 10) { // newline
                break;
            }
            this.buffer.push(byte);
        }
        if (!has_read) {
            return null;
        }
        let line = intrinsics::buffer_to_string(this.buffer.as_slice());
        this.buffer.clear();
        line
    }
}

export class Array {
    fn length() intrinsics::array_length(this);
    fn iter() new IndexIterator(this);
    fn push(value) intrinsics::array_push(this, value);
}

export class Object {}

export class Exception {
    constructor(message) {
        print("Exception created:", message);
        {message: message}
    }
}

export class Option {
    constructor(has_value, value) if (has_value) {value: value} else null;
    static fn some(value) new Option(true, value);
    static fn none() new Option(false, null);
    fn is_some() this != null;
    fn is_none() this == null;
    fn unwrap() {
        if (this == null) {
            raise new Exception("Called unwrap on None");
        }
        this;
    }
}

export class TcpListener {
    constructor(listener) {listener: listener};
    async static fn bind(address, port) {
        new TcpListener(await intrinsics::tcp_listen_async(address, port))
    }
    fn accept() {
        print(this.listener);
        intrinsics::tcp_accept_async(this.listener)
    }
}

export class Module {}

print("Loading std.yuzu", TcpListener);

//initialize lazy statics
Array;
Exception;
Number;
Integer;
String;
ClassInstance;
Class;
Resource;
AsyncResource;
Function;
Object;
Bool;
Null;
Option;
Module;
