mod mod1;

print("Module main loaded");
use root::mod1::test_fn;
use root::mod1::TestClass2;

async fn test_async() {
    intrinsics::sys_sleep(1000);
    print("In test_async");
    return 55;
}

async fn main() {
    print("Hello from main.yuzu");
    print(test_fn(3, 4));
    let obj = new root::mod1::TestClass();
    obj.test_method(100, 200);
    print(obj.x, obj.y, obj);
    print(c);
    
    print([1, 2, 3].length());
    for (v in [1,2,3,4]) {
        print(v);
    }

    let a = new TestClass2(3);
    let b = new TestClass2(5);
    let c = a + b;
    print("Created c from a + b:", a,b, c, -c);

    let func = (-11).abs;
    //let papply = func.partial_apply(1, 2, 3);
    //papply(4, 5, 6);
    print("abs", (-10).abs(), func(), func.call());
    try {
        raise "Test exception";
    } catch (e) {
        print("Caught exception:", e);
    }

    let connections = [];

    let listener = new std::TcpListener("127.0.0.1", 8080);
    print("Listening on 127.0.0.1:8080");
    while (true) {
        print("Waiting for connection...");
        let stream = await listener.accept();
        print("Accepted connection", connections.length(), stream);
        connections.push(handle_connection(stream));
    }
}

async fn handle_connection(stream) {
    let reader = new std::BufferedReader(stream);
    while (true) {
        let line = await reader.readline_async();
        if (line == null) {
            break;
        }
        print("Received line:", line);
    }
    print("Connection closed");
}


export let a = 5;
export let c = b + 10;
export let b = a + 10;

print("Starting main", std::TcpListener);

let main = main();
let fut = test_async();
print(fut);
print(await fut);
print(fut);
print("After await");
std::std_test();
await main;
